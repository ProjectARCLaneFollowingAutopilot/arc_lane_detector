// Filtering according to the relative error in the bottom crossings seemed to work badly.
// Check if bottom crossing left isn't more than 40% apart from previous frame.
float bottom_crossing_l = lines_left[index_of_minimal_cost_left][0]*cos(lines_left[index_of_minimal_cost_left][1]) - sin(lines_left[index_of_minimal_cost_left][1])*((src_roi.rows - lines_left[index_of_minimal_cost_left][0]*sin(lines_left[index_of_minimal_cost_left][1]))/(cos(lines_left[index_of_minimal_cost_left][1])));
float bottom_crossing_l_prev = rho_left*cos(theta_left_rad) - sin(theta_left_rad)*((src_roi.rows - rho_left*sin(theta_left_rad))/(cos(theta_left_rad)));
float rel_error_crossing_left = std::abs((bottom_crossing_l - bottom_crossing_l_prev)/bottom_crossing_l_prev);
if(rel_error_crossing_left > 1.0)
{
  rel_error_crossing_left = rel_error_crossing_left - 1.0;
}
else
{
  rel_error_crossing_left = 1.0 - rel_error_crossing_left;
}

if(rel_error_crossing_left < 0.6)
{
  update_left = true;
}
else
{
  update_left = false;
}

// Check if bottom crossing right isn't more than 40% apart from previous frame.
float bottom_crossing_r = lines[index_of_minimal_cost_right][0]*cos(lines[index_of_minimal_cost_right][1]) - sin(lines[index_of_minimal_cost_right][1])*((src_roi.rows - lines[index_of_minimal_cost_right][0]*sin(lines[index_of_minimal_cost_right][1]))/(cos(lines[index_of_minimal_cost_right][1])));
float bottom_crossing_r_prev = rho_right*cos(theta_right_rad) - sin(theta_right_rad)*((src_roi.rows - rho_right*sin(theta_right_rad))/(cos(theta_right_rad)));
float rel_error_crossing_right = std::abs((bottom_crossing_r - bottom_crossing_r_prev)/bottom_crossing_r_prev);
if(rel_error_crossing_right > 1.0)
{
  rel_error_crossing_right = rel_error_crossing_right - 1.0;
}
else
{
  rel_error_crossing_right = 1.0 - rel_error_crossing_right;
}

if(rel_error_crossing_right < 0.6)
{
  update_right = true;
}
else
{
  update_right = false;
}
